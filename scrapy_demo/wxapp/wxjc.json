{"title": "微信小程序开发——导航失效的解决办法 ", "author": "Rolan", "pub_time": "2018-3-16 00:28", "content": "异常描述：使用 navigator 导航，各种属性配置没问题，就是点击死活不跳转。异常分析：遇到这种情况，要先考虑的就是当前配置的导航url，是不是已经使用在tabBar中，因为小程序对于navigator 有如下描述：也就是说navigator 中使用tabBar中的路由链接，是不能使用navigateTo这种方式的，需要使用wx.switchTab()这种方式，也就是说navigate组件的 open-type 需要switchTab。"}
{"title": "在 mpvue 使用 echarts 小程序组件 ", "author": "Rolan", "pub_time": "2018-3-12 00:08", "content": "具体操作下载 echarts-for-weixin 。把其 ec-canvas 目录移动到 mpvue 项目的 static 目录下。对 ec-canvas/ec-canvas.js 进行小调整，考虑提 pr 到 ec-canvas。修改 ready 为异步获取数据。  ready: function () {\r\n  // 异步获取\r\n    setTimeout(() => {\r\n      if (!this.data.ec) {\r\n        console.warn('组件需绑定 ec 变量，例：<ec-canvas id=\"mychart-dom-bar\" '\r\n          + 'canvas-id=\"mychart-bar\" ec=\"{{ ec }}\"></ec-canvas>');\r\n        return;\r\n      }\r\n\r\n      if (!this.data.ec.lazyLoad) {\r\n        this.init();\r\n      }\r\n    }, 10)\r\n  }为 init 添加接收 options 传参      var query = wx.createSelectorQuery().in(this);\r\n      query.select('.ec-canvas').boundingClientRect(res => {\r\n        if (typeof callback === 'function') {\r\n          this.chart = callback(canvas, res.width, res.height);\r\n        }\r\n        else if (this.data.ec && this.data.ec.onInit) {\r\n          this.chart = this.data.ec.onInit(canvas, res.width, res.height);\r\n        }\r\n        else if (this.data.ec && this.data.ec.options) {\r\n        // 添加接收 options 传参\r\n          const ec = this.data.ec\r\n\r\n          function initChart(canvas, width, height) {\r\n            const chart = echarts.init(canvas, null, {\r\n              width: width,\r\n              height: height\r\n            });\r\n            canvas.setChart(chart);\r\n            chart.setOption(ec.options);\r\n            return chart;\r\n          }\r\n          this.chart = initChart(canvas, res.width, res.height);\r\n        }\r\n      }).exec();\r\n创建 pages/bar 页面，目录如下：.\r\n└── pages\r\n    └── bar\r\n        ├── index.vue\r\n        └── main.js\r\n在 main.js 中引入微信小程序的自定义组件import Vue from 'vue'\r\nimport App from './index'\r\n\r\nconst app = new Vue(App)\r\napp.$mount()\r\n\r\n// 添加 config json\r\nexport default {\r\n  config: {\r\n    // 这儿添加要用的小程序组件\r\n    usingComponents: {\r\n      'ec-canvas': '../../../static/ec-canvas/ec-canvas'\r\n    }\r\n  }\r\n}在 app.vue 中添加 options、template 等相关配置<template>\r\n  <div>\r\n    <div class=\"container\">\r\n      <ec-canvas class=\"canvas\" id=\"mychart-dom-bar\" canvas-id=\"mychart-bar\" :ec=\"ec\"></ec-canvas>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nconst options = {\r\n    // more code ... \r\n}\r\n\r\nexport default {\r\n  data () {\r\n    return {\r\n      ec: {\r\n        // 传 options\r\n        options: options,\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n</script>\r\n\r\n<style>\r\nec-canvas {\r\n  width: 400px;\r\n  height: 400px;\r\n}\r\n\r\n</style>\r\nBuild Setup# install dependencies\r\nnpm install\r\n\r\n# serve with hot reload at localhost:8080\r\nnpm run dev\r\n\r\n# build for production with minification\r\nnpm run build\r\n\r\n# build for production and view the bundle analyzer report\r\nnpm run build --report"}
{"title": "小程序--记一次低级并严重的开发失误 ", "author": "Rolan", "pub_time": "2018-3-12 00:16", "content": "1.前言前端从事了超过两年，修复了无数的bug，写了无数的bug；挖了很多次坑，填了很多次坑；犯了很多次错，弥补了很多次，学习了很多次。一般而言，对于bug、坑，都是修复完了或者填完了，并且记住为什么会产生bug，为什么有坑，为什么犯错，怎么解决的，下次怎么避免，就行了，就学习到了。而这一次的项目，原本以为开发挺顺利的，但是开发完了，才发现自己犯了一个低级而严重的错，这样的一个失误，我一直耿耿于怀。2.起因在3月9号的这一天，公司有个活动，希望用答题活动推广自己的小程序。结果因为开发时间太紧，小程序在3月5号才提审。在3月8号早上，小程序还没有审核，在不得已的情况下，只能把答题活动以网页的形式进行，使用vue开发。由于在3月9号要用到这个答题活动，所以3月8号必须要完成开发，测试，验收。开发的过程，都挺顺利，只是把小程序的一些代码，改成vue开发移动端网站的方式，把标签换了，样式稍微重写一下，项目就跑起来了，至于一些交互逻辑，由于不能使用小程序的API，只能另找良方代替，但问题基本不大。麻烦的一个需求就是：当用户没答完题中途退出的时候，要记录用户的答题状态。比如答了哪些题目，哪些题目错了，哪些题目正确了，拿了多少分等数据。在小程序里面，很轻松可以利用生命周期函数 unload() 进行监听。当用户没答完题退出页面的时候，把用户当前的答题数据，传给后台，让后台进行保存。在用户下次进入页面的时候，我可以根据后台返回的用户答题状态，进行信息的展示。如果用户没答过题目，就重新开始答题，如果用户上次退出的时候，没答完题目，就按照退出时的进度，让用户重新答题，如果答完了题目，直接显示答题结果页面。这个需求不难实现，小程序有 onload() 和 unload() 两个生命周期函数，只是在这两个函数里面，调两次接口而已。但在网页里面，监听用户进入页面简单。但是监听用户退出页面（微信浏览器上面的那个‘返回’或者‘关闭’按钮）却死活不行。网上最多的解决方案是这个，但是不知道是我使用方式有问题还是人品问题，压根没用，无论是微信开发者工具，还是安卓或者苹果真机。答案来自知乎： 微信自带浏览器环境内左上角返回、关闭按钮事件监控？pushHistory(); \r\nwindow.addEventListener(\"popstate\", function(e) { \r\n    alert(\"我监听到了浏览器的返回按钮事件啦\");//根据自己的需求实现自己的功能 \r\n}, false); \r\nfunction pushHistory() { \r\n    var state = { \r\n        title: \"title\", \r\n        url: \"#\"\r\n    }; \r\n    window.history.pushState(state, \"title\", \"#\"); \r\n}根据网上的方案，试了几个（包括vue的生命周期函数），没一个可行的。最后无奈之下，只能用一个蠢方法，用户点击每一题选项的时候，就把用户当前的记录，通过接口发给后台，让后台记录。这个就是我该文章说的低级严重的失误，想必大家也知道是怎么回事了。3.失误分析这次的答题活动，一共有三轮，每轮10道题，现场大概有500人答题。本来使用小程序开发，不管用户是没答题就让用户可以开始答题，答题途中退出就记录状态，答完题就显示结果。在这个过程中，我跟后台交互的只有两次：一次是用户进来的时候获取用户答题进度，一次是用户答完了最后一题，发送用户成绩，让后台记录；或者中途退出，发送用户答题进度给后台，让后台记录。但是后来我在网页中，由于暂时没法监听用户是否退出，所以选择了用户回答完每一题的时候，把数据发给后台，让后台答题进度。这样请求数就多了N倍。服务器的压力就大了很多。由于用户进来，无论是小程序还是网站，都要请求接口，获取用户答题数据，这次不在对比范围。这样原本小程序只需要和后台进行一次握手，但是在网页中，采用了不合适的方式，和后台握手次数变成了10次。足足多了90%。如果是500人，每一轮从原本的500次，变成了5000次，三轮就从原本的1500次，变成了15000次！一般而言，10道题选择题，是两分钟左右的回答时间，就相当于在2分钟内服务器要响应的次数多了90%，这个担子突然重了很多。而已这些请求，基本都有没什么意义的，因为绝大部分的人，10道题，大概两分钟的答题时间里面，不会中途退出，相当于我做了一件没意义，又消耗服务器性能的事情。让我耿耿于怀的原因，我一向对请求数严格的控制，虽然现在公司不怎么考虑性能，服务器压力。但是这会引起我的强迫症。4.解压方案由于答题活动，9号要使用，而我是8号晚上洗完澡的时候和同事聊天的时候才想起，所以我没时间改了，因为改了也是需要时间开发，测试。9号由于同事请假，他的项目也由我负责，也是比较赶的项目，我也没那么多时间改。只能委屈一下服务器了。说是这样说，但是关于其他的给服务器减轻负担的方案，还是有比较讲一下，算是给自己提个醒，也算是给大家提个醒。开发要注意一点：不要急，不要急，不要急。PS：当时就是看着时间差不多是下午四点半了，然后还有两个零散功能没做，又要测试。找了很久的解决方案（监听微信的‘返回’或者‘关闭按钮’）都没下落的情况下，一下急了，脑袋放空，就想了那个方法。cookie或者localstore记录用户的状态，这个应该是最好的解决方案了，也应该是最简单的解决方案。比如使用cookie记录用户的答题进度。在用户每答一题的时候，就把cookie记录到的数据，更新一次。这样只需要在用户答完了最后一题的时候再把用户的成绩发给后台就好，至于用户中途退出也没有，根据cookie判断就好，如果cookie有记录到用户的数据。就显示上次用户退出时候的题目，让用户继续答题。原代码：/**\r\n* @dedependson 点击选项\r\n* @index 题目索引  number\r\n* @item 当前选项对象 object\r\n*/\r\nchooseDo(index,item){\r\n    /*其他代码略*/\r\n    let _this=this;\r\n    let _data={\r\n        qid:_this.qid,//答题轮次，如'2'代表第二轮答题\r\n        questions:_this.questions,//已答题目，'1,2,3'这个表示id为1，2，3的题目已经回答了\r\n        totalScore:_this.totalScore//当前得分\r\n    }\r\n    //发送请求，让后台记录用户答题进度\r\n    this.$http.post(http_url.submit,_data,{emulateJSON:true}).then(res=>{\r\n            \r\n    })\r\n}然后再到页面加载的时候mounted(){\r\n    this.$http.get(http_url.getQuestions,{\r\n        params:{\r\n            qid:this.qid\r\n        }\r\n    }).then(res=>{\r\n        res=res.body;\r\n        //如果请求成功\r\n        if(res.code===0){\r\n            //如果用户没答完题 0-没开始答题 1-没答完题   2-答完题目\r\n            if(res.datas.status!==2){\r\n                //获取答题的题目\r\n                this.questionList=res.datas.entryList;\r\n                //如果题目长度小于10，就是开始答题了，但是没答完（中途退出的原因）\r\n                if(this.questionList.length<10){\r\n                    //显示答题页面，让用户答题\r\n                    this.questionListShow=true;\r\n                }\r\n                //否则就是没答过题目，让用户答题\r\n                else{\r\n                    //显示开始答题页面（答题首页，用户需要点击开始答题）\r\n                }\r\n            }\r\n            //如果用户已经答完题，显示结果页\r\n            else{\r\n                //代码略\r\n            }\r\n        }\r\n        else{\r\n            alert(res.msg)\r\n        }\r\n    })\r\n}cookie方案chooseDo(index,item){\r\n    /*其他代码略*/\r\n    let _this=this;\r\n    let _data={\r\n        qid:_this.qid,//答题轮次，如'2'代表第二轮答题\r\n        questions:_this.questions,//已答题目，'1,2,3'这个表示id为1，2，3的题目已经回答了\r\n        totalScore:_this.totalScore//当前得分\r\n    }\r\n    //保存cookie一天\r\n    //_this.qid作为答题轮次的标识\r\n    setCookie('answer-qid'+_this.qid,_this.qid,1);\r\n    setCookie('answer-questions'+_this.qid,_this.questions,1);\r\n    setCookie('answer-totalScore'+_this.qid,_this.totalScore,1);\r\n}cookie函数参考: ec-do//设置cookie\r\nsetCookie(name, value, iDay) {\r\n    let oDate = new Date();\r\n    oDate.setDate(oDate.getDate() + iDay);\r\n    document.cookie = name + '=' + value + ';expires=' + oDate;\r\n},\r\n//获取cookie\r\ngetCookie(name) {\r\n    let arr = document.cookie.split('; '),arr2;\r\n    for (let i = 0; i < arr.length; i++) {\r\n        arr2 = arr[i].split('=');\r\n        if (arr2[0] == name) {\r\n            return arr2[1];\r\n        }\r\n    }\r\n    return '';\r\n},\r\n//删除cookie\r\nremoveCookie(name) {\r\n    this.setCookie(name, 1, -1);\r\n},然后再到页面加载的时候，处理方式的改变。mounted(){\r\n    this.$http.get(http_url.getQuestions,{\r\n        params:{\r\n            qid:this.qid\r\n        }\r\n    }).then(res=>{\r\n        res=res.body;\r\n        //如果请求成功\r\n        if(res.code===0){\r\n            //如果用户没答完题 0-没开始答题 1-没答完题   2-答完题目\r\n            if(res.datas.status!==2){\r\n                //记录答题轮次\r\n                this.qid=res.datas.qid; \r\n                //获取答题的题目\r\n                this.questionList=res.datas.entryList; \r\n                //如果用户中途退出，我们没有和后台对接口，后台无法记录用户答题进度，所以这次请求，返回的结果要么是没开始答题，要么是答完题了。\r\n                //要还原用户答题记录，要使用cookie\r\n                //如果存在cookie记录，那么用户肯定是至少答过一题，还原用户答题进度\r\n                let _answerQid=getCookie('answer-qid'+this.qid)\r\n                _answerQuestions=getCookie('answer-qid'+this.qid).split(',');\r\n                //字符串转整数\r\n                _answerQuestions.map(item=>+item);\r\n                \r\n                if(_answerQid&&_answerQuestions){\r\n                    this.questionList.fifler(item=>{\r\n                        //item.id是题目的id\r\n                        //如果题目的id存在，就过滤掉\r\n                        _answerQuestions.indexOf(item.id)===-1\r\n                    });\r\n                    //显示答题页面，让用户答题\r\n                    this.questionListShow=true;  \r\n                }\r\n                //否则就是没答过题目，让用户答题\r\n                else{\r\n                    //显示开始答题页面（答题首页，用户需要点击开始答题）\r\n                }\r\n            }\r\n            //如果用户已经答完题，显示结果页\r\n            else{\r\n                //代码略\r\n            }\r\n        }\r\n        else{\r\n            alert(res.msg)\r\n        }\r\n    })\r\n}代码上面，可能用了 cookie 会复杂些，但是就多了几行而已，差不了多少，反倒是减轻了很多请求。在小程序没有使用这个方案，就是考虑到用户退出小程序，可能会清除缓存，虽然这个几率不大，所以使用生命周期函数进行 unload() 进行监听，用户退出就把用户答题进度提交给后台，让后台记录，这样的情况不会很多，甚至没有，请求不会很多，所以当时就用了这个方案。没有使用cookie或者localstore。注意几点：1.无论什么情况，开发都需要一个清醒的头脑，因为头脑不清醒，写的都是bug，那个活动是一个一次性的项目，如果是长期的，我肯定会重构的，因为当时写的代码太烂了。也容易犯一些低级的错误。2.不要为了小概率的事件想得太多，给自己，同事，服务器都带来麻烦，也影响项目进度。这次就是想得太多，结果提测的时间晚了，验收的时间晚了，自己也犯了错误。想太多的后果可能就是捡了芝麻，漏了西瓜，甚至是偷鸡不成蚀把米。2.小结这次的的失误就告一段落了，我也总结了一下，自己为什么会对这次失误更更于怀。1.最近一直在看怎么优化代码，让代码更有可读性，可维护性。却犯了请求数过多的错。顾此失彼啊。2.第二个就是因为这次失误，导致的后果太严重了，直接多了90%的请求。以往失误导致的后果没怎么严重。3.以往犯错的时候，在项目上线之前能够发现，并且有时候改，这次不一样，这次是发现了，但是没时间改了。4.那些以为不会有，不应该犯的错。可能就在头脑不清醒的时候，就会犯这些错误，无论什么时候都得留个神，这次也算是我自己提醒自己了。不过结局是还算是好的，当天因为时间关系，答题活动没有进行，所以服务器没有受到考验。如果当天服务器承受不住压力，崩了，我也可能要引咎辞职了！好了，故事就是这样了，有点日记的感觉，希望大家谅解下。如果文章有什么地方写错了，也欢迎指点交流。--------------------华丽的分割线-------------------想了解更多，关注关注我的微信公众号：守候书阁"}
{"title": "微信小程序优化 ", "author": "Rolan", "pub_time": "2018-3-12 00:28", "content": "setDatasetData 是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。在介绍常见的错误用法前，先简单介绍一下 setData 背后的工作原理。工作原理小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。常见的 setData 操作错误1. 频繁的去 setData在我们分析过的一些案例里，部分小程序会非常频繁（毫秒级）的去setData，其导致了两个后果：Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；2. 每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程，3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。图片资源目前图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。图片对内存的影响在 iOS 上，小程序的页面是由多个 WKWebView 组成的，在系统内存紧张时，会回收掉一部分 WKWebView。从过去我们分析的案例来看，大图片和长列表图片的使用会引起 WKWebView 的回收。图片对页面切换的影响除了内存问题外，大图片也会造成页面切换的卡顿。我们分析过的案例中，有一部分小程序会在页面中引用大图片，在页面后退切换中会出现掉帧卡顿的情况。当前我们建议开发者尽量减少使用大图片资源。代码包大小的优化小程序一开始时代码包限制为 1MB，但我们收到了很多反馈说代码包大小不够用，经过评估后我们放开了这个限制，增加到 2MB 。代码包上限的增加对于开发者来说，能够实现更丰富的功能，但对于用户来说，也增加了下载流量和本地空间的占用。开发者在实现业务逻辑同时也有必要尽量减少代码包的大小，因为代码包大小直接影响到下载速度，从而影响用户的首次打开体验。除了代码自身的重构优化外，还可以从这两方面着手优化代码大小：控制代码包内图片资源小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。 但我们分析数据发现，不同小程序之间的代码包压缩比差异也挺大的，部分可以达到 30%，而部分只有 80%，而造成这部分差异的一个原因，就是图片资源的使用。GZIP 对基于文本资源的压缩效果最好，在压缩较大文件时往往可高达 70%-80% 的压缩率，而如果对已经压缩的资源（例如大多数的图片格式）则效果甚微。及时清理没有使用到的代码和资源在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。"}
{"title": "微信小程序_如何支持Less等CSS框架开发 ", "author": "Rolan", "pub_time": "2018-3-12 00:32", "content": "先说点什么呢，小程序很强大，但官方开发工具美中不足，不支持Scss，Less 等样式框架，只能支持原生CSS，所以这里琢磨一下怎么样如何支持Less 等。mac 环境Less，Scss 等Webstorm下载地址WeChatCodejar 代码提示地址安装 Less首先 确保安装了 npm， 然后执行 npm install less -g ，稍等一会，安装完成后 出现下图，红线框内 是 路径。\r\n增加文件类型 wxml，wxss打开 webstorm，Preferences -> Editor -> File Types 各自添加 *.wxml，*.wxss 等格式的文件， 并记录在 HTML 和 Less 上增加文件监听打开 webstorm，Preferences -> Tools > File Watcher 创建 文件监听，添加\r\n增加文件类型模板打开 webstorm，Preferences -> Editor -> File and Code Templates，添加wxss 新的文件类型模板\r\n 这个时候，每新建一个 Less 文件，都会创建 wxss 文件，Less 文件是用 Less 的语法，wxss 文件 是被自动转译成 原生CSS 的语法，之后直接编写 Less 文件内容，会自动同步且转译到 wxss 文件内，由此 才可被 微信开发工具识别，顺利运行。 注意 ：等到项目开发的差不多时，若觉得*.less 和 *.css 文件占用太多空间，可在终端用 命令 直接 删除即可。注意 ：还有个问题，因为使用小程序的 API，导致大量报错 而且没有提示，可以在 webstorm 导入 WechatCodejar，避免一下这个情况然后 我们就暂时脱离了 微信开发工具 中编程，但还是要在 微信开发工具中看效果，一边是 webstorm 强大的 IDE编写代码，一边是官方工具自动编译预览，简直不要太爽。"}
{"title": "JAVA版微信小程序用户数据的签名验证和加解密 ", "author": "Rolan", "pub_time": "2018-3-13 00:21", "content": "签名验证和加解密数据签名校验为了确保 开放接口 返回用户数据的安全性，微信会对明文数据进行签名。开发者可以根据业务需要对数据包进行签名校验，确保数据的完整性。签名校验算法涉及用户的session_key，通过 wx.login 登录流程获取用户session_key，并自行维护与应用自身登录态的对应关系。通过调用接口（如 wx.getUserInfo）获取数据时，接口会同时返回 rawData、signature，其中 signature = sha1( rawData + session_key )开发者将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。加密数据解密算法接口如果涉及敏感数据（如wx.getUserInfo当中的 openId 和unionId ），接口的明文内容将不包含这些敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据( encryptedData )进行对称解密。解密算法如下：对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。对称解密的目标密文为 Base64_Decode(encryptedData),对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节对称解密算法初始向量 iv 会在数据接口中返回。微信官方提供了多种编程语言的示例代码（ 点击下载 ），但就是没提供JAVA版本的，可能的确PHP是最好的语言，腾讯提供的demo好多都是PHP版本的。JAVA代码案例pom.xml引入以下依赖：<dependency>\r\n     <groupId>commons-codec</groupId>\r\n     <artifactId>commons-codec</artifactId>\r\n     <version>1.10</version>\r\n</dependency>\r\n<dependency>\r\n     <groupId>com.alibaba</groupId>\r\n     <artifactId>fastjson</artifactId>\r\n     <version>1.2.7</version>\r\n</dependency>\r\n <dependency>\r\n     <groupId>org.bouncycastle</groupId>\r\n     <artifactId>bcprov-jdk15on</artifactId>\r\n     <version>1.57</version>\r\n</dependency>我们可以参考PHP给出的代码，使用JAVA实现： AESUtil：import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\nimport java.security.AlgorithmParameters;\r\nimport java.security.InvalidAlgorithmParameterException;\r\nimport java.security.InvalidKeyException;\r\nimport java.security.Key;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.NoSuchProviderException;\r\nimport java.security.Security;\r\nimport javax.crypto.BadPaddingException;\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.IllegalBlockSizeException;\r\nimport javax.crypto.NoSuchPaddingException;\r\nimport javax.crypto.spec.IvParameterSpec;\r\nimport javax.crypto.spec.SecretKeySpec;\r\n/**\r\n * AES解密\r\n * 创建者 柒\r\n * 创建时间\t2018年3月12日\r\n */\r\npublic class AESUtil {\r\n\t\r\n\tstatic {\r\n\t\tSecurity.addProvider(new BouncyCastleProvider());\r\n\t}\r\n\r\n\t/**\r\n\t * AES解密\r\n\t * @param content 密文\r\n\t * @return\r\n\t * @throws InvalidAlgorithmParameterException\r\n\t * @throws NoSuchProviderException\r\n\t */\r\n\tpublic static byte[] decrypt(byte[] content, byte[] keyByte, byte[] ivByte)\r\n\t\t\tthrows InvalidAlgorithmParameterException {\r\n\t\ttry {\r\n\t\t\tCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\r\n\t\t\tKey sKeySpec = new SecretKeySpec(keyByte, \"AES\");\r\n\t\t\t//生成iv\r\n\t\t\tAlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\r\n\t\t\tparams.init(new IvParameterSpec(ivByte));\r\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, sKeySpec, params);// 初始化\r\n\t\t\treturn cipher.doFinal(content);\r\n\t\t} catch (NoSuchAlgorithmException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (NoSuchPaddingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (InvalidKeyException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (IllegalBlockSizeException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (BadPaddingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n}WXBizDataCrypt：import java.io.UnsupportedEncodingException;\r\nimport java.security.InvalidAlgorithmParameterException;\r\nimport org.apache.commons.codec.binary.Base64;\r\nimport org.apache.commons.lang.StringUtils;\r\nimport com.alibaba.fastjson.JSON;\r\nimport com.alibaba.fastjson.JSONObject;\r\n/**\r\n * 对微信小程序用户加密数据的解密\r\n * 创建者 柒 \r\n * 创建时间 2018年3月12日\r\n */\r\npublic class WXBizDataCrypt {\r\n\t\r\n\tpublic static String illegalAesKey = \"-41001\";//非法密钥\r\n\tpublic static String illegalIv = \"-41002\";//非法初始向量\r\n\tpublic static String illegalBuffer = \"-41003\";//非法密文\r\n\tpublic static String decodeBase64Error = \"-41004\"; //解码错误\r\n\tpublic static String noData = \"-41005\"; //数据不正确\r\n\r\n\tprivate String appid;\r\n\r\n\tprivate String sessionKey;\r\n\r\n\tpublic WXBizDataCrypt(String appid, String sessionKey) {\r\n\t\tthis.appid = appid;\r\n\t\tthis.sessionKey = sessionKey;\r\n\t}\r\n\r\n\t/**\r\n\t * 检验数据的真实性，并且获取解密后的明文.\r\n\t * @param encryptedData  string 加密的用户数据\r\n\t * @param iv  string 与用户数据一同返回的初始向量\r\n\t * @return data string 解密后的原文\r\n\t * @return String 返回用户信息\r\n\t */\r\n\tpublic String decryptData(String encryptedData, String iv) {\r\n\t\tif (StringUtils.length(sessionKey) != 24) {\r\n\t\t\treturn illegalAesKey;\r\n\t\t}\r\n\t\t// 对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。\r\n\t\tbyte[] aesKey = Base64.decodeBase64(sessionKey);\r\n\r\n\t\tif (StringUtils.length(iv) != 24) {\r\n\t\t\treturn illegalIv;\r\n\t\t}\r\n\t\t// 对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。\r\n\t\tbyte[] aesIV = Base64.decodeBase64(iv);\r\n\r\n\t\t// 对称解密的目标密文为 Base64_Decode(encryptedData)\r\n\t\tbyte[] aesCipher = Base64.decodeBase64(encryptedData);\r\n\r\n\t\ttry {\r\n\t\t\tbyte[] resultByte = AESUtil.decrypt(aesCipher, aesKey, aesIV);\r\n\t\t\tif (null != resultByte && resultByte.length > 0) {\r\n\t\t\t\tString userInfo = new String(resultByte, \"UTF-8\");\r\n\t\t\t\tJSONObject jsons = JSON.parseObject(userInfo);\r\n\t\t\t\tString id = jsons.getJSONObject(\"watermark\").getString(\"appid\");\r\n\t\t\t\tif (!StringUtils.equals(id, appid)) {\r\n\t\t\t\t\treturn illegalBuffer;\r\n\t\t\t\t}\r\n\t\t\t\treturn userInfo;\r\n\t\t\t} else {\r\n\t\t\t\treturn noData;\r\n\t\t\t}\r\n\t\t} catch (InvalidAlgorithmParameterException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (UnsupportedEncodingException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * encryptedData 和 iv 两个参数通过小程序wx.getUserInfo()方法获取\r\n\t * @param args\r\n\t * @see\r\n\t */\r\n\tpublic static void main(String[] args) {\r\n\t\tString appId = \"wx4f4bc4dec97d474b\";\r\n\t\tString sessionKey = \"tiihtNczf5v6AKRyjwEUhQ==\";\r\n\t\tString encryptedData = \"CiyLU1Aw2KjvrjMdj8YKliAjtP4gsMZM\"\r\n\t\t\t\t+ \"QmRzooG2xrDcvSnxIMXFufNstNGTyaGS\"\r\n\t\t\t\t+ \"9uT5geRa0W4oTOb1WT7fJlAC+oNPdbB+\"\r\n\t\t\t\t+ \"3hVbJSRgv+4lGOETKUQz6OYStslQ142d\"\r\n\t\t\t\t+ \"NCuabNPGBzlooOmB231qMM85d2/fV6Ch\"\r\n\t\t\t\t+ \"evvXvQP8Hkue1poOFtnEtpyxVLW1zAo6\"\r\n\t\t\t\t+ \"/1Xx1COxFvrc2d7UL/lmHInNlxuacJXw\"\r\n\t\t\t\t+ \"u0fjpXfz/YqYzBIBzD6WUfTIF9GRHpOn\"\r\n\t\t\t\t+ \"/Hz7saL8xz+W//FRAUid1OksQaQx4CMs\"\r\n\t\t\t\t+ \"8LOddcQhULW4ucetDf96JcR3g0gfRK4P\"\r\n\t\t\t\t+ \"C7E/r7Z6xNrXd2UIeorGj5Ef7b1pJAYB\"\r\n\t\t\t\t+ \"6Y5anaHqZ9J6nKEBvB4DnNLIVWSgARns\"\r\n\t\t\t\t+ \"/8wR2SiRS7MNACwTyrGvt9ts8p12PKFd\"\r\n\t\t\t\t+ \"lqYTopNHR1Vf7XjfhQlVsAJdNiKdYmYV\"\r\n\t\t\t\t+ \"oKlaRv85IfVunYzO0IKXsyl7JCUjCpoG\"\r\n\t\t\t\t+ \"20f0a04COwfneQAGGwd5oa+T8yO5hzuy\"\r\n\t\t\t\t+ \"Db/XcxxmK01EpqOyuxINew==\";\r\n\t\tString iv = \"r7BXXKkLb8qrSNn05n0qiA==\";\r\n\r\n\t\tWXBizDataCrypt biz = new WXBizDataCrypt(appId, sessionKey);\r\n\r\n\t\tSystem.out.println(biz.decryptData(encryptedData, iv));\r\n\r\n\t}\r\n}运行main方法，获取返回结果：{\"openId\":\"oGZUI0egBJY1zhBYw2KhdUfwVJJE\",\"nickName\":\"Band\",\"gender\":1,\"language\":\"zh_CN\",\"city\":\"Guangzhou\",\"province\":\"Guangdong\",\"country\":\"CN\",\"avatarUrl\":\"http://wx.qlogo.cn/mmopen/vi_32/aSKcBBPpibyKNicHNTMM0qJVh8Kjgiak2AHWr8MHM4WgMEm7GFhsf8OYrySdbvAMvTsw3mo8ibKicsnfN5pRjl1p8HQ/0\",\"unionId\":\"ocMvos6NjeKLIBqg5Mr9QjxrP1FA\",\"watermark\":{\"timestamp\":1477314187,\"appid\":\"wx4f4bc4dec97d474b\"}}作者：小柒出处： https://blog.52itstyle.com分享是快乐的，也见证了个人成长历程，文章大多都是工作经验总结以及平时学习积累，基于自身认知不足之处在所难免，也请大家指正，共同进步。本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出, 如有问题， 可邮件（345849402@qq.com）咨询。"}
{"title": "微信小程序中实现手指缩放图片 ", "author": "Rolan", "pub_time": "2018-3-13 00:25", "content": "公司开发微信小程序，pm想实现如下需求：用手指缩放图片。其实在实现这个需求以前，并不知道，微信公众号以及微信小程序里面有一个原生的api就自带这个特效，而且微信朋友圈也是用的这个api。wx.previewImage，就是它。预览图片。除了不能预览开发环境的本地电脑的图片外，你手机真机的图片，以及http服务器上的图片都是可以预览的，而且缩放功能做得很流畅。下面就说说如何用js来实现这个功能吧。文章里面的思路参考此文章：链接描述先上源码，然后在逐步剖析：Page({\r\n    data: {\r\n        touch: {\r\n            distance: 0,\r\n            scale: 1,\r\n            baseWidth: null,\r\n            baseHeight: null,\r\n            scaleWidth: null,\r\n            scaleHeight: null\r\n        }\r\n    },\r\n    touchstartCallback: function(e) {\r\n        // 单手指缩放开始，也不做任何处理\r\n        if(e.touches.length == 1) return\r\n        console.log('双手指触发开始')\r\n        // 注意touchstartCallback 真正代码的开始\r\n        // 一开始我并没有这个回调函数，会出现缩小的时候有瞬间被放大过程的bug\r\n        // 当两根手指放上去的时候，就将distance 初始化。\r\n        let xMove = e.touches[1].clientX - e.touches[0].clientX;\r\n        let yMove = e.touches[1].clientY - e.touches[0].clientY;\r\n        let distance = Math.sqrt(xMove * xMove + yMove * yMove);\r\n        this.setData({\r\n           'touch.distance': distance,\r\n        })\r\n    },\r\n    touchmoveCallback: function(e) {\r\n        let touch = this.data.touch\r\n        // 单手指缩放我们不做任何操作\r\n        if(e.touches.length == 1) return\r\n        console.log('双手指运动')\r\n        let xMove = e.touches[1].clientX - e.touches[0].clientX;\r\n        let yMove = e.touches[1].clientY - e.touches[0].clientY;\r\n        // 新的 ditance\r\n        let distance = Math.sqrt(xMove * xMove + yMove * yMove);\r\n        let distanceDiff = distance - touch.distance;\r\n        let newScale = touch.scale + 0.005 * distanceDiff\r\n        // 为了防止缩放得太大，所以scale需要限制，同理最小值也是\r\n        if(newScale >= 2) {\r\n            newScale = 2\r\n        }\r\n        if(newScale <= 0.6) {\r\n            newScale = 0.6\r\n        }\r\n        let scaleWidth = newScale * touch.baseWidth\r\n        let scaleHeight = newScale * touch.baseHeight\r\n        // 赋值 新的 => 旧的\r\n        this.setData({\r\n           'touch.distance': distance,\r\n           'touch.scale': newScale,\r\n           'touch.scaleWidth': scaleWidth,\r\n           'touch.scaleHeight': scaleHeight,\r\n           'touch.diff': distanceDiff\r\n        })\r\n    },\r\n    bindload: function(e) {\r\n      // bindload 这个api是<image>组件的api类似<img>的onload属性\r\n      this.setData({\r\n          'touch.baseWidth': e.detail.width,\r\n          'touch.baseHeight': e.detail.height,\r\n          'touch.scaleWidth': e.detail.width,\r\n          'touch.scaleHeight': e.detail.height\r\n      })\r\n    }\r\n})\r\nwxml文件对应如下，就不做解释了：<view class=\"container\">\r\n    <view bindtouchmove=\"touchmoveCallback\" bindtouchstart=\"touchstartCallback\">\r\n        <image src=\"../../resources/pic/cat.jpg\" style=\"width: {{ touch.scaleWidth }}px;height: {{ touch.scaleHeight }}px\" bindload=\"bindload\"></image>\r\n    </view>\r\n</view>"}
{"title": "微信小程序--答题系统实现随机出题 ", "author": "Rolan", "pub_time": "2018-3-6 00:34", "content": "最近头脑王者非常火爆，公司也在开发类似头脑王者的答题系统，这个重任交到我这边来了，我们在开发的这个微信小程序答题系统，需要实现随机出题。尤其是一些比如闯关的环节，需要随机从题库里抽取若干道题目，给到用户答题。那么要如何来做呢？首先我们要做两张表，一张是exam表，用来存考卷的。另外一张是题库表，question表。在exam表里设置好考试的参数，比如说本次考试是随机抽多少题，然后在sql语句中，随机从question表中抽取题目。注意了，划重点了，一些关键点来了。随机抽题目，一般人想到的是sql语句的 order by rand ，然后网上你搜下 order by rand语句的优化，也有人提到过，这个order by rand 执行效率很低。尤其是比如你的题库很大，如果你做大平台的，一定会在后期发生的。我们自己是做平台的，开发好这套系统是要不断的复制卖给所有的需要的客户的。所以客户出的题目肯定会越来越多，题库要越赖越大的。题库随着考试次数增多，题库将会变的非常大。所以提前就要想好解决办法，一次性把代码写到位。小程序答题系统 小程序答题使用ORDER BY RAND 一个15万余条的库，查询5条数据，居然要8秒以上。查看官方手册，也说rand()放在ORDER BY 子句中会被执行多次，自然效率及很低。怎么优化方法很多，大家自行百度，我用的是使用sql语句 limit的偏移量来做的。话不多说，直接上代码了。tp的风格哈。$total=$questionTable->where($search)->count();  //查看下对应的题目总数有多少        if($total<=$getrand_Num){ //总的题目数比需要的还小  那就不用随机了 直接出全部的题目就行了            $offset = 0;        }else{            $offset = mt_rand(0, $total-1);  //偏移量        }        $list=$questionTable->where($search)->field($field)->limit($offset,$getrand_Num)->select();不知道各位看懂了没有，这个偏移量的，就是使用这个模式来随机抽取题目。希望你也按照这个思路优化下你的考试答题系统的随机出题逻辑。我，秋峰，phper，目前自创业，做项目系统开发，php后端加小程序前端结合 今天就给大家分享到这里，希望对大家有所帮助。欢迎交流 大家相互学习 共同提高 我的 微信号：qiufeng2999"}
{"title": "微信小程序基础 ", "author": "Rolan", "pub_time": "2018-3-7 00:25", "content": "2018 年过了不到一个月，时间虽短但有一样新东西在这短短时间里就火了起来。从“跳一跳”，到“坦克大战”，再到“头脑王者”，微信小游戏好像突然将时间拉回到了过去。餐桌上、休息时大家不再是各自刷着微博、段子，而是聚在一起开始一场场紧（ge）张（zhong）刺（zhuang）激（bi）的对战。小游戏充分利用了人们零碎的时间，并将娱乐和社交有效地结合起来。在小游戏推出之前，本人是看衰小程序的，所以一直没有入坑。然而，小游戏狠狠地打了我的脸，它的出现让我眼前一亮，不单单让我觉得小游戏有着很大的想象空间，更让我觉得微信这个平台有着无限的可能。当前，微信是将小游戏作为小程序的一个分类，所以暂时先亡羊补牢看看什么是小程序。小程序要学一样新东西的最好办法自然是看官网教程。小程序的官网是微信公众平台，其他什么乱七八糟的都是外包广告啦~在官网上可以轻松地找到小程序和小游戏的教程。微信的教程也相当详细，这边就不再赘述了。如果跟着教程走，其中第二步微信会推荐你安装一个开发者工具，这里要吹一波这个工具。接近完美的开发者工具新版的开发者工具和之前仅能够用于调试的代理工具完全不同，可以说是鸟枪换炮。接着就来看一下这个工具到底惊艳在哪里？首次打开工具，你会看到一个类似下图的界面，会让你填一些项目的基础信息。其中的 AppID 可以通过注册获得，不过即使没有 AppID 也可以先创建项目进行开发，这里先选体验小程序。如果，选择一个空文件夹作为项目的目录，那么，在工具的最下方就会出现一个模板项目的选项。勾选它，创建的项目就包含了一个微信的 Demo 项目。这个小功能当然不是这个工具的亮点所在，这里先点确定生成一个 Demo 项目。登登登等~有没有被惊艳到？工具左上角的 3 个按钮分别控制模拟器、编辑器和调试器区域的显示与否。模拟器和调试器的模样是不是非常熟悉？[滑稽]这个开发者工具可以说是集成了浏览器和 IDE，以及代理等工具于一身，所有的开发工作几乎可以在这一个工具中完成，再也不用在一个个应用之间来回切换了。整洁、干净、完美！（要被吸粉了...）PS: 虽然，可以在设置里修改编辑器的配置，不过和真正的 IDE 比样子还是丑了一点。开发工具就说到这，更多功能等你自己去探索。看完了酷炫的工具，平复一下心情，继续来看 Demo 项目。WXML, WXSS 和 WXS在 Demo 项目中，你会看到两种新类型的文件：.wxml 和 .wxss。这也是我之前看（xian）衰（qi）小程序的主要原因，它并没有使用标准的文件类型及语法，而是创立了一套微信自己的标准。WXML先看一下 wxml 里面究竟有什么名堂？<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view class=\"userinfo\">\r\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"> 获取头像昵称 </button>\r\n    <block wx:else>\r\n      <image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n    </block>\r\n  </view>\r\n  <view class=\"usermotto\">\r\n    <text class=\"user-motto\">{{motto}}</text>\r\n  </view>\r\n</view>是不是又很熟悉？这不就是多了些默认组件的 vue 嘛。需要注意的是，{{}} 与引号之间不能有空格，否则会解析为字符串。其他语法层面就没有什么难点了，再撸一遍基础组件文档就差不多了。WXSSwxss 的变化就更小了，就多提供了一个单位 rpx。1rpx 等于屏幕尺寸的 1/750。（UI 出 750 的图就很好做啦...）剩下就提供了一些简单的选择器，类、Id、元素和前后的伪类，没有其他的学习成本。最后说一下 wxs（Demo 项目中没有用到）。WXS什么是 WXS？微信官方是这样说的：WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。但是，整个文档看下来，除了在模块的处理上有些许的不同之外，其他可以说是破产版的 js 吧。既然，它是 js 的子集，那么，都用 js 来写也没什么毛病，暂时也没有看出什么场景必须使用它。感觉整套都是 kpi 的产物哪...小程序其他的配置文件文档里已经写得很清晰了。至此，小程序的基础就暂告一段落，下篇将关于小游戏相关内容，敬请期待。"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "初级前端小程序项目加载速度优化 ", "author": "Rolan", "pub_time": "2018-1-4 00:25", "content": "这份文字是根据近期团队做来问丁香医生 SPA 和 丁香医生小程序 加载速度优化的经历整理而成。效果古人有一句话叫做：治感冒看疗效。既然是关于速度优化的，我们就先来看一下优化的效果。来问丁香医生Chrome Network选取了访问量较大的首页和我的页面进行随机取样，通过下图可以看到首页的加载时间从 5.1s 下降到 1.67s，我的页面从 2.92s 下降到 1.82s。mta2018.01.02 早上的页面响应速度数据，目前国内各省份平均加载速度在 0.99~2s（虽然没有达到 1s 内加载，但是以目前业务量级，这样的速度是可以被接受的）：前者这是 Google 的一个评分工具，最开始做优化时用它测了一些页面的分数。后来发现了后面这些 Chrome 插件。让我困惑的是同样的页面这几个工具给出的结果分数都不一样。手淘 的首屏加载速度挺快的，但是跑出来的分数也不高。最终我只是选择性的参考一下工具给出来的建议，忽视了其给出的评分。丁香医生小程序对于小程序，做了优化后得到部门同学的反馈是这样的：具体的数据指标如何呢？虽然目前没有特别好用的性能检测方式（包括官方提供的性能检测工具在内），最终我们组的舒哲同学还是利用官方提供的工具做了一下简单的数据对比，数据如下：在不影响产品需求正常迭代的前提下，两个项目的优化断断续续持续了两周。整体上来说，本次优化的性价比还是较高的。为什么做加载速度优化？直接原因很简单：慢。虽然说页面加载速度并没有达到慢的让人无法忍受，但至少没办法让人说加载很快。既然明知道加载速度不快，那之前在干什么？为什么不早早的去做优化呢？这是一个好问题，我曾经在深夜中问过自己多次。我给自己的答案是：首先，要承认自身技术水平和经验的限制，如果是一个在前端战场上身经百战的人一直在负责项目的迭代，或许情况会比优化前好一些。 其次，之前整个产品线的项目一直处于探索和快速迭代中，前端研发资源基本上总是处在被需求排满的状态下，产品需求快速上线的优先级是最高的。正是因为产品的整体节奏稍微放缓了一些，才让研发资源有精力来做一些优化。为什么说是前端响应速度优化，而不是前后端？因为我是亲眼看着这两个项目逐渐长大的，单从前端工程的角度来审视，在自己的认知范围内，早就认为项目中有一些地方是需要优化的。坚定了先从前端动手的想法，是因为读了《高性能网站建设指南》这本书，书中提到了一个性能黄金法则（Performance Golden Rule）：只有 10% ~ 20% 的最终用户响应时间是花在下载 HTML 文档上。话说到这个份上，还犹豫什么呢，先从前端项目开始撸起袖子加油干吧。之前去 Qcon 等技术大会上，听过几次关于加载速度的分享。比如：使用 HTTP2，整站级别的前后端优化等。方案确实是好的方案，但具体是否要应用到自己团队实际项目中，还得根据执行成本、团队技术储备等维度从长计议。为什么说是初级？因为深感自己在前端性能优化这个领域还有很长的路要走。如何做的？前戏这么长，终于可以开始了。来问丁香医生 SPA先看图（绿色部分为已在项目中应用的方法）：实现游客机制最初来问丁香医生是基于微信服务号做的，当时的设计是用户通过服务号菜单进入应用时，会自动帮他进行跳转登录，登录成功后服务端再重定向回到应用。登录这个环节，虽然与项目代码层面的加载优化关系不大，但是从用户体验的角度这样的流程是不好的。因为相比于直接打开页面，用户需要等更长的时间，并且会看到两次页面加载的进度条。从产品的角度，一些页面是不需要用户登录即可访问的。综上，将登录流程后置，让用户可以直接进入应用这件事情，于情于理都是必须要做的。改造流程大致为：梳理产品现有流程 -> 用户进入应用时取消强制登录 -> 在产品流程核心环节进行用户登录状态判断并引导登录。具体实现细节不再赘述。减小资源包体积实现了游客机制后，接下来就是对应用的资源包动手了。因为通过 Chrome 开发者工具的 Network 可以看出，下载 CSS、JS 资源还是占用了不少时间的。下图是减小资源包体积之前的情况：优化前包体积大小-Gzipped精简第三方依赖想要减少资源体积大小，首先需要知道哪些资源时应该/可以被删除的。由于项目是基于 Webpack 构建的，因此可以使用 Webpack Bundle Analyzer 进行分析Webpack 生成的包体组成。然后根据实际情况进行移除就好。精简了第三方依赖后，启动应用时需要下载的资源体积还是挺大的。此时就需要使用 Webpack 的代码分离和懒加载进行进一步的优化。代码分离代码分离的思想就是化整为零，将代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些小的 bundle 文件。代码分离主要是利用 Webpack 的动态导入Webpack 目前有三种常用的代码分离方法：入口起点：使用 entry 配置手动地分离代码。（优势：简单、直观。劣势：配置繁琐、同一份代码可能会被引入到各个 bundle 中、不灵活，并不能将核心应用程序逻辑进行动态拆分代码）防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。动态导入：通过模块的内联函数调用来分离代码。经过对比之后，最终选择了动态导入的方式。动态导入(dynamic imports)webpack 提供了两个类似的技术：import() 语法（推荐，符合 ECMAScript 提案）require.ensure（webpack 钦定）示例// 分离 lodash\r\nasync function getComponent() {\r\n    const _ = await import(/* webpackChunkName: \"lodash\" */ 'lodash');\r\n}懒加载懒加载是在代码分离的基础上更近了一步。虽然我们可以将代码进行代码分离，但代码分离后的 bundle 只是加载的优先级会不同，最终还是会加载，但实际情况是某些代码在用户进行某项操作之前是不需要加载的。比如：个人信息编辑页面有一个用户修改头像功能，对于用户来说，即使他进入了个人信息编辑页面，在他未点击上传按钮之前，用于上传头像的代码是没必要加载的。Vue-Router 结合 Vue 的异步组件和 Webpack 的代码分割功能，实现了路由组件的懒加载。在经过精简依赖、代码分离和懒加载之后，项目的资源包体积大小如下图：Gzipped：用户进入首页需要加载的 js 资源从 vendor.js 、 main.js 和 chunks 共 672.84kb 变为只需要加载一个 186kb 的 main.js 。复用 Store 数据以减少网络请求数量来问丁香医生是基于Vue.js 全家桶实现的，状态管理用的是Vuex。之前的实现中，有些功能实现没有很在意 Store 数据的复用。比如：从 A 页面进入 B 页面后再返回 A 页面时，会再去获取端获取一次 A 页面需要的数据。这种处理不仅仅是多发了不必要的请求，如果在请求过程中做了一些页面级别加载中的处理，那么每次切换页面时都会让用户看到 loading 效果，这也会让人觉得加载慢。既然用了状态管理，那么就应该把他利用好才是。本次优化过程中的数据复用，主要是在部分请求 action 之前增加逻辑判断，如果 Store 中有当前操作需要的数据，则不再调用 action 。前后端彻底分离关于这一点会再写一篇文章进行阐述。丁香医生小程序老规矩，先看图：图片资源最开始做小程序时，是把所有图片资源 base64 后进行使用的，这导致了所有图片资源最终都被打包到小程序的安装包中。所以做小程序的加载速度优化的第一步，就是把一些体积较大的图片资源改为使用线上资源。具体做法是将素材先上传到 cdn，然后在小程序中直接使用线上图片地址。登录鉴权优化原本小程序的登录是我们自己实现的一套登录方案，核心是前后端一起维护一个类似于 SessionId 的 ID。服务端对于这个 ID 是设置了有效期的，而之前前端的实现是每次用户启动小程序，都直接去请求公司的 SSO 获取一个新的 ID，没有在意本地的 ID 是否过期。优化的点在于在应用启动时，增加对 ID 有效期的判断，从而避免每次用户启动都需要发请求获取新的 ID。预渲染之前在小程序所有需要从服务端获取数据的页面，都实现了一个加载中的效果，即请求未返回结果时，整个页面用户只会看到一个加载中的菊花。如果某页面只有服务端提供的元数据级别接口，没有业务接口，并且接口返回的数据是有依赖关系的，那么用户等待的时间会大大加长。仔细思考会发现，其实是没有必要等所有接口数据回来后再给用户呈现完整页面的。最终的优化方案分为两种：一种是取消加载中效果，先给用户呈现完整的利用本地数据渲染好的页面，等接口返回数据后在进行页面视图的更新；另外一种方案是取消加载中效果，但是不做本地数据渲染，而是直接给用户看到部分静态页面。分包加载关于分包加载，就老老实实的按照官方文档做就好了。进行分包后的效果还是很不错的。具体效果可以参考文章开头的数据统计。目前上述方案中，效果比较明显的是预渲染和分包加载。一个是视觉上让用户觉得快了，一个是真真切切的把首次加载的资源包变小了。"}
{"title": "微信小程序--TabBar不出现 ", "author": "Rolan", "pub_time": "2018-1-9 00:22", "content": "今天打算开始实战一个微信小程序项目，一开始就踩坑了，正确设置了TabBar，但是TabBar就是不能显示出来，后面才找到原因，这里记录下：\r\napp.json正确代码：\r\n{  \"pages\":[    \"pages/index/index\",     \"pages/leader/leader\",        \"pages/leader/stories/stories\",     \"pages/leader/authors/authors\",     \"pages/stack/stack\",    \"pages/stack/booklist/booklist\",     \"pages/stack/booklist/bookdetail/bookdetail\",    \"pages/bookdesk/bookdesk\",     \"pages/mine/mine\",    \"pages/mine/news/news\",        \"pages/logs/logs\"   ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"网易蜗牛读书\",    \"navigationBarTextStyle\":\"black\"  },  \"tabBar\":{    \"color\":\"#999999\",    \"selectedColor\":\"#444444\",    \"backgroungColor\":\"#ffffff\",    \"borderStyle\":\"#e0e0e0\",    \"list\": [      {        \"pagePath\":\"pages/leader/leader\",        \"iconPath\": \"assets/icons/lingdu.png\",        \"selectedIconPath\": \"assets/icons/lingdu_sel.png\",        \"text\":\"领读\"      },      {        \"pagePath\":\"pages/stack/stack\",        \"iconPath\": \"assets/icons/stack.png\",        \"selectedIconPath\": \"assets/icons/stack_sel.png\",        \"text\":\"分类\"      },      {        \"pagePath\": \"pages/bookdesk/bookdesk\",        \"iconPath\": \"assets/icons/bookdesk.png\",        \"selectedIconPath\": \"assets/icons/bookdesk_sel.png\",        \"text\":\"书桌\"      },      {        \"pagePath\":\"pages/mine/mine\",        \"iconPath\": \"assets/icons/mine.png\",        \"selectedIconPath\": \"assets/icons/mine_sel.png\",        \"text\":\"我的\"      }    ]  }}\r\n这里注意显示解决有两种方式：\r\n1.pages里的首个页面必须在list数组里有配置，所以在lists数组里加一个字典对象即可。\r\n{        \"pagePath\":\"pages/index/index\",        \"iconPath\": \"assets/icons/index.png\",        \"selectedIconPath\": \"assets/icons/index_sel.png\",        \"text\":\"首页\" }\r\n但是我的TabBar又不想有这个item显示，这里看第二种解决办法。\r\n2.pages数组的第一项必须是tabBar的list数组的一员：\r\n这里有个疑惑：\r\n百度了解决方法，显示将list数组加了index的模块item，后面不想要index模块在TabBar显示，然后又删除再运行，问题就解决了，也没有设置pages数组的第一项必须是tabBar的list数组的一员。\r\n解决了就好，知道的大神可以留言告诉我哟！"}
{"title": "我是如何次次《头脑王者》获得满分的 ", "author": "Rolan", "pub_time": "2018-1-16 00:27", "content": "前言最近答题类的应用实在是太火了，什么冲顶大会、百万英雄啊，动不动就几十上百万的奖金，着实让人看着很是眼红...然后本弱鸡学疏才浅...题目全靠蒙，便不凑什么热闹了。之后没过几日有个小程序倒是在办公室里面火了一把，就是这次需要拿来开刀的《头脑王者》，其实也是个答题的小程序，所以还是不擅长就是了。虽然我不擅长答题，但我好歹是个程序员呀，所以我走上了一条程序员的通顶之路...成果每轮游戏需要答5题，全对并且快速作答才能拿到满分，满分是1200分。有了这种战绩，世界第一不是梦！当然玩游戏是为了乐趣，本弱鸡只是出于兴趣使然，这种答题类的游戏还是自己玩比较有意思。准备工作在开始写这种游戏的辅助之前先思考几个问题。如何伪造接口请求？如何实现精准答题？如何完成自动答题？如何伪造接口请求？首先小程序的接口请求都是基于HTTPS的，具体捕获Https的方式我这边还是采用Anyproxy去捕获，需要安装对应的Https证书才可以。之前的文章也有提及，这里再赘述一遍。本文采用的Anyproxy，使用其他的代理工具也是一样的。1. 安装node.js2. npm i -g anyproxy3. anyproxy-ca // 生成证书4. anyproxy -i // 以代理https的方式启动// 然后手机端配置代理的IP及PORT，默认端口为8001，// Anyproxy的WebService的默认端口为8002，这里可以查看到接口// 手机端配置代理以后需要下载证书并信任，// 苹果端的可以在手机的Safiri里面输入xxx.xxx.xxx.xxx:8002/fetchCrtFile的方式下载到证书// 高版本的iOS可能需要在两处地方信任。配置完以后，打开游戏就能抓取到头脑王者对应的请求包了。我先模拟了一次好友对战，然后需要分析了哪些包是需要的。这里我就直接把一些重要的接口给贴出来了login接口（登录接口，这里重要的信息是uid和token）intoRoom接口 （进入房间的接口）beginFight接口 （开始对战接口）findQuiz接口 （找题目接口）choose接口 （答题接口）getResults接口 （获取比赛结果的接口）leaveRoom接口 （离开房间接口）先从接口看一下，这是一个非常顺畅的游戏流程，但是拿到这些接口我就可以开始为所欲为了吗？显然是不可能的，如果每个人都能有权限肆意使用别人的接口的话，岂不是可以很轻松的做到DDoS攻击或者很轻松地获取到自己想要的信息了吗？对于一家有经验的公司来说显然是不会犯这种错误的，那么我随便拿一个接口来稍作分析。上图是天梯排位匹配接口，从Body中可以看到需要传给服务端matchId、npcId、uid、t、sign五个参数，这5个参数都是必须的，只有有一个参数出错，那请求就无法成功，前四个其实好理解，关键是第五个签名参数sign，是怎么来的呢？这里就需要用到逆向工程了...简单的描述就是...拿到小程序中头脑王者压缩后的源码，并分析出其中的加密规则，篇幅有限，这里就直接描述其加密规则了。sign的生成规则：Body内所有的参数（除去sign）+ token（login接口获取）并按照key值排序以后对齐进行MD5加密,比如uid=111， t=222， token=333，那么加密前子串应为t=222token=333uid=111既然sign也有了，那其实就很简单了，然后我就用node写一个简单的client去做伪造了接口请求。如何实现精准答题？目前也有许多冲顶大会、百万英雄的辅助，他们的思路是答题的时候快速识别到题目并进行快速的搜索题目进行辅助答题，但对于这款游戏，如果想实现精准的答题的话，最好的办法就是匹配题库，那么问题就是题库怎么来？当然是通过爬虫去爬取的了，OK...来让我们找一找题库的接口！显然这是不可能的！要是对外开放了题库的接口，这个游戏也太容易被攻破了把。但是从上述的一步中，其实我们已经实现了开房模拟对战了，那么是不是可以一直开房间一直对战的方式获取到题库呢？所以我这里采用的就是这种思路。success是脚本自动答题打对的题目（一共5题），total是总共的题库数量。从这个规模可以看出来，正确率已经是极高的了，说明题库的数量应该估计只有17000左右的范围，但是由于剩下的题库仍然在补充且最后的10%会需要较大的成本才能覆盖到，其实题库做到这一步已经足够了，80%+的满分概率...几乎已经是无人匹敌了吧？如何实现自动答题？自动答题的方案有两种：类似跳一跳游戏，通过截屏=>OCR读取题目=>匹配题库=>模拟点击答案Anyproxy代理，写rule文件修改请求，捕获findQuiz请求接口，server重新发起请求并等待数据返回=>判断返回的题目是否已经存在于数据库=>匹配答案直接作答或返回题目本弱鸡在这里使用的就是第二种方案（具体实现就不赘述了，大家可以直接看源码）总结不太善于写文章，上述很多步骤都简单带过了，在这里只是简单地描述了一下过程，然后我会开源这部分的代码，写得有些简陋希望各位大佬们不要嘲笑(由于在写Anyproxy的rule的时候没法使用babel，所以我用require取代了import）。最后希望大家能给与我一点支持及肯定，给点star吧...只要10个不过分吧！有好心能请我喝杯咖啡那就万分感谢了。>.<如有在尝试的时候碰到问题，也可以加本弱鸡的wx: lyh2668项目地址GitHub: 头脑王者辅助"}
{"title": "微信小程序组件化的解决方案（上） ", "author": "Rolan", "pub_time": "2018-1-25 00:21", "content": "从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。查看自己使用的小程序基础库版本，可以通过在开发者工具右侧点击详情查看：最基本的组件小程序的组件，其实就是一个目录，该目录需要包含4个文件：xxx.jsonxxx.wxmlxxx.wxssxxx.js声明一个组件首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）{\r\n  \"component\": true\r\n}其次，在要引入组件的页面的json文件内，进行引用声明{\r\n  \"usingComponents\": {\r\n    //自定义的组件名称     ： 组件路径，注意是相对路径，不能是绝对路径  \r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n} 这样，在主页面就可以使用了。相比于vue的组件引入，小程序的方案更简洁。vue组件引入是需要 import 之后，同时在 components 里面注册，而小程序的组件只需要在 .json 里面注册，就可以在 wxml 里面使用。使用slot和vue 相同，小程序也有slot概念。单一slot在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。// 主页面内，<addlike>是组件\r\n<addlike item=\"item\" my_properties=\"sssss\">\r\n    <text>我是被slot插入的文本</text>\r\n</addlike>\r\n \r\n// addlike 组件\r\n<view class=\"container\">\r\n    <view>hello, 这里是组件</view>\r\n    <view>hello, {{my_properties}}</view>\r\n    <slot></slot>\r\n</view>\r\n \r\n// 渲染后\r\n<view class=\"container\">\r\n    <view>hello, 这里是组件</view>\r\n    <view>hello, {{my_properties}}</view>\r\n    <text>我是被slot插入的文本</text>\r\n</view>多个slot如果需要在组件内使用多个slot， 需要在组件js中声明启用：Component({\r\n  options: {\r\n    multipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n  },\r\n  properties: { /* ... */ },\r\n  methods: { /* ... */ }\r\n})使用：// 主页面\r\n<addlike item=\"item\" my_properties=\"sssss\">\r\n    // 在普通的元素上加入 slot 属性，指定slotname, 就可以变成子元素的slot了\r\n    <text slot=\"slot1\">我是被slot1插入的文本</text>\r\n    <text slot=\"slot2\">我是被slot2插入的文本</text>\r\n</addlike>\r\n \r\n// 子页面\r\n<view class=\"container\">\r\n    <view>hello, 这里是组件</view>\r\n    <view>hello, {{my_properties}}</view>\r\n    <slot name=\"slot1\"></slot>\r\n    <slot name=\"slot2\"></slot>\r\n</view>Component构造器 刚才我们说了，一个组件内应该包括js,  wxml, wxss, json 四个文件。wxml 相当于是 HTML，wxss 相当于是 css, 那么js 里面应该写什么呢？微信官方提供的案例中：Component({\r\n \r\n  behaviors: [],\r\n \r\n  properties: {\r\n   \r\n  },\r\n  data: {}, // 私有数据，可用于模版渲染\r\n \r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached: function(){},\r\n  moved: function(){},\r\n  detached: function(){},\r\n \r\n  methods: {\r\n    onMyButtonTap: function(){\r\n     \r\n    },\r\n    _myPrivateMethod: function(){\r\n     \r\n    },\r\n    _propertyChange: function(newVal, oldVal) {\r\n \r\n    }\r\n  }\r\n})里面调用了一个Component构造器。Component构造器可用于定义组件，调用Component构造器时可以指定组件的属性、数据、方法等。具体 Component里面可以放什么东西，如下所示：组件与数据通信组件化必然要涉及到数据的通信，为了解决数据在组件间的维护问题，vue, react，angular 有不同的解决方案。而小程序的解决方案则简洁很多。主页面传入数据到组件properties相当于vue的props，是传入外部数据的入口。// 主页面使用组件\r\n<a add_like=\"{{add_like}}\">\r\n</a>\r\n \r\n// 组件a.js 内\r\nComponent({\r\n    properties:{\r\n        add_like:{\r\n            type:Array,\r\n            value:[],\r\n            observer:function(){\r\n                \r\n            }\r\n        }\r\n    }\r\n})注意： 传入的数据，不管是简单数据类型，还是引用类型，都如同值复制一样（和红宝书里面描述js函数参数传入是值复制还不一样，红宝书里面的意思是：简单数据类型直接复制数值，引用类型复制引用，也就是说在函数内修改参数对象的属性，会影响到函数外对象的属性）。如果是Vue的props， 则可以通过 .sync 来同步，而在小程序子组件里面，调用this.setData()修改父组件内的数据，不会影响到父组件里面的数据, 也就是说，子组件property的修改，仿佛和父组件没有任何关系。那么，如果是在子组件内修改父组件的数据，甚至是修改兄弟组件内的数据，有没有简单的方法呢？下面会有讲到 组件传出数据到主页面和vue类似，组件间交互的主要形式是自定义事件。组件通过 this.triggerEvent() 触发自定义事件，主页面在组件上 bind:component_method=\"main_page_mehod\" 来接收自定义事件。其中，this.triggerEvent() 方法接收自定义事件名称外，还接收两个对象，eventDetail 和 eventOptions。// 子组件触发自定义事件\r\nontap () {\r\n    // 所有要带到主页面的数据，都装在eventDetail里面\r\n\tvar eventDetail = {\r\n\t\tname:'sssssssss',\r\n\t\ttest:[1,2,3]\r\n\t}\r\n\t// 触发事件的选项 bubbles是否冒泡，composed是否可穿越组件边界，capturePhase 是否有捕获阶段\r\n\tvar eventOption = {\r\n\t\tcomposed: true\r\n\t}\r\n\tthis.triggerEvent('click_btn', eventDetail, eventOption)\r\n}\r\n \r\n// 主页面里面\r\nmain_page_ontap (eventDetail) {\r\n    console.log(eventDetail)\r\n    // eventDetail\r\n    // changedTouches\r\n    // currentTarget\r\n    // target\r\n    // type\r\n    // ……\r\n    // detail   哈哈，所有的子组件的数据，都通过该参数的detail属性暴露出来\r\n}组件之间数据通信和vue提出的vuex的解决方案不同，小程序的组件间的通讯简单小巧。你可以和主页面与组件通讯一样，使用自定义事件来进行通讯，当然更简单方便的方法，是使用小程序提供的relations.relations 是Component 构造函数中的一个属性，只要两个组件的relations 属性产生关联，他们两个之间就可以捕获到对方，并且可以相互访问，修改对方的属性，如同修改自己的属性一样。Component({\r\n   relations:{\r\n    './path_to_b': {                 // './path_to_b'是对方组件的相对路径\r\n        type: 'child',               //  type可选择两组：parent和child、ancestor和descendant\r\n        linked:function(target){  }  // 钩子函数，在组件linked时候被调用 target是组件的实例，\r\n        linkChanged: function(target){}\r\n        unlinked: function(target){}\r\n        }\r\n    },\r\n})比如说，有两个组件如代码所示：// 组件a slot 包含了组件b\r\n<a>\r\n    <b></b>\r\n</a>他们之间的关系如下图所示： 两个组件捕获到对方组件的实例，是通过 this.getRelationNodes('./path_to_a')方法。既然获取到了对方组件的实例，那么就可以访问到对方组件上的data, 也可以设置对方组件上的data, 但是不能调用对方组件上的方法。 // 在a 组件中\r\nComponent({\r\n    relations:{\r\n        './path_to_b': {\r\n            type: 'child',\r\n            linked:function(target){  }  // target是组件b的实例，\r\n            linkChanged: function(target){}\r\n            unlinked: function(target){}\r\n        }\r\n    },\r\n    methods:{\r\n        test () {\r\n            var nodes = this.getRelationNodes('./path_to_b')\r\n            var component_b = nodes[0];\r\n            \r\n            // 获取到b组件的数据\r\n            console.log(component_b.data.name)\r\n            \r\n            // 设置父组件的数据\r\n            // 这样的设置是无效的\r\n            this.setData({\r\n                component_b.data.name:'ss'\r\n            })\r\n            // 需要调用对方组件的setData()方法来设置\r\n            component_b.setData({\r\n                name:'ss'\r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 在b 组件里面\r\nComponent({\r\n    relations:{\r\n        './path_to_a': {                      //注意！必须双方组件都声明relations属性\r\n            type:'parent'\r\n        }\r\n    },\r\n    data: {\r\n        name: 'dudu'\r\n    }\r\n}) 注意：1. 主页面使用组件的时候，不能有数字，比如说 <component_sub1> 或 <component_sub_1>，可以在主页面的json 里面设置一个新名字{\r\n    \"usingComponents\":{\r\n        \"test_component_subb\": \"../../../components/test_component_sub2/test_component_sub2\"\r\n    }\r\n}2. relations 里面的路径，比如说这里：﻿是对方组件真实的相对路径，而不是组件间的逻辑路径。3. 如果relations 没有关联，那么 this.getRelationNodes 是获取不到对方组件的4. 本组件无法获取本组件的实例，使用this.getRelatonsNodes('./ path_to_self ') 会返回一个null4. type 可以选择的 parent 、 child 、 ancestor 、 descendant"}
{"title": "《欢乐坦克大战》微信小游戏开发总结 ", "author": "Rolan", "pub_time": "2018-1-30 00:30", "content": "前言      《欢乐坦克大战》是一款支持3V3实时对战并首批参与上线的微信小游戏中的作品。因为该游戏为微信小游戏中的重度之作，项目开发周期非常短，所以游戏复杂度、开发难度、性能挑战也是挺大的；项目组在一个月内就完成了单机、网络对战玩法的开发。        同时，因为客户端开发团队的核心成员有多年的cocos2dx引擎开发经验，所以项目组决定使用CocosCreator V1.6.1版本的引擎进行开发。而对于微信小游戏平台采用的javascript语言，开发团队基本上是从0开始做，边学边做，对自身挑战很大。一、架构        网络通信方面项目采用了WebSocket协议进行通信，而通信格式是json。为了迎合tdr的xml协议，项目组自己开发了tdr->json的转换工具。        为了方便策划同学使用excel表格进行数据配置，项目组又开发了将excel转换成json文件的工具，以便供客户端读取配置文件。        地图方面我们没有使用cocos引擎自带的TileMap，而是自己实现了一个类TileMap机制。策划同学可以在excel中配置地图信息，使用工具将excil转换成json格式的地图文件供客户端加载。        由于开发进度紧张，需要同时开发单机和PVP玩法。所以我们封装了一个命令层(CMD层)来进行战斗逻辑驱动。比如使用摇杆控制坦克运动，是由表现层发送CMD命令给逻辑层进行处理，在单机模式下CMD会存储于客户端本地列表，然后由命令管理器CMDMgr在Update时读取本地命令列表驱动逻辑层进行处理。而在对战模式中，CMD命令会被发往服务器，由服务器广播给所有玩家，玩家客户端的命令管理器CMDMgr在Update时驱动逻辑层进行处理。引入命令层(CMD层)之后，战斗逻辑层是抽象独立的，开发不需要关心当前的玩法模式，可以方便的复用，减少了开发成本。        我们PVP实时对战采用的是c/s模式的同步架构，客户端做碰撞检测，将碰撞检测结果通知服务器，服务器进行校验并做伤害计算，然后广播给其他玩家。游戏支持断线重连、客户端crash重连机制，服务器拥有战斗中的所有状态数据，重连时将所有数据发送给客户端，客户端进行战斗场景还原。       玩家位置同步采用了基于时间戳的位置点同步算法。这个算法原先应用于《全民飞机大战》的双打模式、对抗模式中。《全民飞机大战》中实时对战采用的是UDP通信。而在《欢乐坦克大战的》WebSocketTCP环境下也取得了不错的效果。算法原理如下：二、挑战     在开发过程中，我们也遇到了不少挑战，但是我们都一一解决了，具体遇到的问题如下：1、微信小游戏平台增加了动态执行代码的限制       微信小游戏平台增加了动态执行代码的限制，比如：eval('console.log(1)')、new Function(‘console.log(1)')、setTimeout('console.log(1)’) 等调用方式无法调用。而在CocosCreatorV1.6.1源码中大量使用了Function，为了解决这个问题，我们和cocos引擎开发商的沟通了下，又参考cocos在1.7版本（当时尚未发布）中的修改，修改了一些源码，解决了此问题。2、微信小游戏不允许超过4M     正如标题所示，微信小程序严格要求了大小，为了解决这个问题，我们又想了不少办法。措施1：引擎定制裁剪去掉不必要的模块减少引擎体积，这块通过设置引擎模块即可。措施2：图片压缩       使用png图片压缩工具pngquant，可以有效的减小png图片的文件大小（通常能压缩60%-70%）左右。通过以上2个措施，资源仍然会超标，只能采用资源动态下载的方案了。措施3：资源动态下载       我们在游戏中增加了一个资源更新场景。游戏启动时，场景进行资源更新时游戏业务模块都没有创建，等到游戏场景中再进行业务模块的创建和初始化工作，然后再进行场景切换。具体方案如下：      1.先下载一个资源更新配置文件，此文件中有待资源下载列表、资源校验MD5信息。      2.根据资源下载列表，将校验MD5和本地文件进行对比，如果相同则不下载，如果不同则下载。      3.下载完毕后，进行MD5校验，如果校验不通过则删除本地文件，重新走下载流程。这里的MD5校验，不仅可以校验资源下载是否正确；对于防止资源被恶意修改，资源反作弊也有一定作用。      4.修改cocos引擎源码， 在load-pipeline中，将资源读取替换成读取本地的下载文件。      由于游戏运营中可能会有Bug发生，需要下发客户端补丁。资源更新配置文件可能会被多次修改，而CDN更新会有延迟问题，导致部分玩家下载的配置文件可能是较旧的版本。而且有部分中小运营商，为了成本考虑，会缓存旧的文件。以往的项目在发生这种情况时，一般是联系玩家进行定位，发现是运营商问题再反馈给运维同学，由网络部门的同事推动运营商进行修改，效率不高。为了减少这种情况发生的可能性，我们使用了双CDN策略。      具体的做法是，对于同名文件增加版本号机制，更新文件时将文件内部存储版本号+1，并在2个不同的CDN进行更新。客户端下载时，下载2份文件，取版本号大的为准。这样当更新配置文件时，2个不同CDN只要有一个同步到即可，既能减少了CDN更新延迟，又降低了运营商缓存问题出现的概率。3、性能优化     和一般的游戏不同的是，微信小游戏平台本身的js脚本执行效率较弱，iOS环境小游戏javascript引擎目前使用的是JavaScriptCore，默认没开jit优化，js执行速度会比手机safari慢，从简单测试结果来看，速度会慢两倍左右。从Profiler来看，js脚本执行时间会占到80%左右。因此减少脚本的计算量也是性能优化一个重要的方面。小米6android小游戏android 微信浏览器android chrome57.555358iphone6IOS小游戏IOS 微信浏览器IOS safari204850                                                                   帧率测试对比为了解决这些问题，项目组做了以下优化DrawCall       渲染批次合并和大多游戏项目类似，需要合理的规划图集的使用，将同一个层次的GameObj使用的图片资源进行拼图。       可以分为地图背景层、地表、地图物件、坦克、子弹、特效、UI等拼图，尽量确保同一个层次的游戏对象使用相同的图集，相邻的精灵使用的材质相同。mask       游戏中会显示玩家的圆形头像，而微信平台下载的头像是矩形。原先头像显示使用的是cocos的mask组件进行渲染，效率较低。我们自己实现了一个基于mesh的控件，将一个圆等分为n个三角形，给这些三角形顶点赋予相应的UV，从而画出一个圆形头像。减少了头像渲染时的批次开销。碰撞检测      cocos creator自带的碰撞系统效率不高，没有做空间划分，不适合大量单位的碰撞检测。并且每帧都需要更新碰撞体的碰撞盒。我们游戏地图中存在大量的静态物件（如地图中的砖块、主基地、钢板等），而玩家在场景中移动时，是通过移动摄像机达到地图视野的变化，所以大量的地图静态物件的世界坐标是不变的，他们的碰撞盒只需要计算一次即可。      为了解决这个问题，我们给cocos的node增加了一个属性static，static节点的计算结果可以缓存起来，避免重复计算。对象池      游戏中的坦克、子弹、砖块等采用对象池，进入战斗场景时有足够数量的预加载，战斗过程中进行复用，避免实时的对象创建与销毁。避免场景、节点更新     分析cocoscreator的源码发现，当有节点发生active，会触发递归遍历场景，开销较大。     为了避免这类开销，游戏中的物体死亡时，不会将其从场景中移除或禁用，而是设置死亡状态，通过移动坐标到很远的地方，代码中不执行相应的逻辑处理。尽量保持帧率平稳，避免性能曲线的毛刺裁剪     当物体不在主角视野范围内并且不是持久播放的特效和声音可以进行裁剪不播放。机型适配      对于美术资源进行了高、中、低3档分级，由策划在资源表格中配置不同分级下的资源名称。游戏过程中，根据机型和实际性能表现，选择一种档次进行表现。       图中横坐标是时间（单位秒），纵坐标是FPS，可以看出FPS有了明显提升。通过一系列的优化措施，最终保证了低端机iphone5S基本能满足游戏需要。       以上就是《欢乐坦克大战》微信小游戏开发总结，有兴趣的小伙伴可以一起来交流哦~"}
{"title": "《冷暖自知》天气小程序 ", "author": "Rolan", "pub_time": "2018-2-6 00:17", "content": "《冷暖自知》天气小程序学无止境，以玩儿玩儿的心态去学习！前一天晚上写的，写的不太好，第二天马上修改了，如有差错，请多指教。花半天时间完成简单的小程序应用。适合小程序初学者。步骤：申请小程序帐号： 小程序注册入口, 具体操作按照官网步骤执行，相信你会看的很明白的（-安装微信开发者工具，打开工具填写信息：①项目目录为自己要开发小程序的位置②AppId在微信管理后台的设置-开发设置中③项目名称自己起，填写完成点击完成；看到默认的初始小程序Hello Horld是不是很兴奋，以上步骤不是我们今天研究的重点，下面进行我们的关键：在index.wxml中写我们的结构，index.wxss中写css样式，在index.js中写我们的逻辑内容。前提是要有css3和javascript的基础哦！！！在index.js中定义两个方法：getLocation()获取用户的地理位置，getWeather()获取天气的方法;和风天气提供免费天气接口（无偿打广告，哈哈~~），免费版只能获取3天的天气情况，开发文档废话不多说，直接上代码~~~代码index.wxml部分<!--index.wxml-->\r\n<view class=\"container\">\r\n<view class=\"weather yesterday\">\r\n<view>\r\n<view class='date'>今天</view>\r\n<view class='location'>{{basic.location}}/{{basic.parent_city}}</view>\r\n<view class='tmp'>{{today.tmp_min}}℃~{{today.tmp_max}}℃</view>\r\n<view class='cond_txt'>{{today.cond_txt_d}}</view>\r\n</view>\r\n<view>\r\n<view class='weather_icon'>\r\n<image src='{{todyIcon}}'></image>\r\n</view>\r\n<view class='lastUpdateDate'>最后更新：{{update}}</view>\r\n</view>\r\n</view>\r\n<view class=\"weather today\">\r\n<view>\r\n<text>明天</text>\r\n<view class='location'>{{basic.location}}/{{basic.parent_city}}</view>\r\n<view class='tmp'>{{tomorrow.tmp_min}}℃~{{tomorrow.tmp_max}}℃</view>\r\n<view class='cond_txt'>{{tomorrow.cond_txt_d}}</view>\r\n</view>\r\n<view>\r\n<view class='weather_icon'>\r\n<image src='{{tomorrowIcon}}'></image>\r\n</view>\r\n<view class='lastUpdateDate'>最后更新：{{update}}</view>\r\n</view>\r\n</view>\r\n<view class=\"weather tomorrow\">\r\n<view>\r\n<text>后天</text>\r\n<view class='location'>{{basic.location}}/{{basic.parent_city}}</view>\r\n<view class='tmp'>{{afterTomor.tmp_min}}℃~{{afterTomor.tmp_max}}℃</view>\r\n<view class='cond_txt'>{{afterTomor.cond_txt_d}}</view>\r\n</view>\r\n<view>\r\n<view class='weather_icon'>\r\n<image src='{{afterTomorIcon}}'></image>\r\n</view>\r\n<view class='lastUpdateDate'>最后更新：{{update}}</view>\r\n</view>\r\n</view>\r\n</view>\r\nindex.wxss部分/**index.wxss**/\r\n.container {\r\n height: 100%;\r\n width: 100%;\r\n display: flex;\r\n flex-direction: column;\r\n align-items: center;\r\n justify-content: space-between;\r\n padding: 10px 15px;\r\n box-sizing: border-box;\r\n} \r\n.weather{\r\n height: 110px;\r\n width: 100%;\r\n margin-bottom: 10px;\r\n border-radius: 5px;\r\n color: #FFF;\r\n padding: 5PX 15px;\r\n display: flex;\r\n font-size: 14px;\r\n box-sizing: border-box;\r\n}\r\n.weather>view{\r\n flex: 1;\r\n}\r\n.weather>view>view{\r\n margin: 5px 0;\r\n}\r\n.yesterday{\r\n background-color: #30BCAF;\r\n}\r\n.today{\r\n background-color: #78A4be;\r\n}\r\n.tomorrow{\r\n background-color: #FCB654;\r\n}\r\n.location,.cond_txt{\r\n font-size: 14px;\r\n}\r\n.date,.tmp{\r\n font-weight: bold;\r\n}\r\n.weather_icon{\r\n text-align: center;\r\n height: 65px;\r\n}\r\n.weather_icon image{\r\n width: 75px;\r\n height: 100%;\r\n}\r\n.lastUpdateDate{\r\n font-size: 10px;\r\n text-align: center;\r\n}\r\nindex.js部分//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nPage({ \r\n data: {\r\n   update: '',\r\n   basic:{},\r\n   today:{},\r\n   tomorrow:{},\r\n   afterTomor:{},\r\n   todyIcon:'../../imgs/weather/999.png',\r\n   tomorrowIcon:'../../imgs/weather/999.png',\r\n   afterTomorIcon:'../../imgs/weather/999.png'\r\n},\r\n onShow: function () {\r\nthis.getLocation();\r\n},\r\n//事件处理函数\r\n bindViewTap: function() {\r\n   wx.navigateTo({\r\n     url: '../logs/logs'\r\n})\r\n},\r\n getLocation:function(){\r\nvar that = this;\r\n   wx.getLocation({\r\n     type: 'wgs84',\r\n     success: function (res) {\r\nvar latitude = res.latitude\r\nvar longitude = res.longitude\r\n       that.getWeatherInfo(latitude, longitude);\r\n}\r\n})\r\n},\r\n getWeatherInfo: function (latitude, longitude){\r\nvar _this = this;\r\nvar key = '';//你自己的key\r\n//需要在微信公众号的设置-开发设置中配置服务器域名\r\nvar url = 'https://free-api.heweather.com/s6/weather?key='+key+'&location=' + longitude + ',' + latitude;\r\n   wx.request({\r\n     url: url, \r\n     data: {},\r\n     method: 'GET',\r\n     success: function (res) {\r\nvar daily_forecast_today = res.data.HeWeather6[0].daily_forecast[0];//今天预报\r\nvar daily_forecast_tomorrow = res.data"}
{"title": "微信小程序之状态管理B ", "author": "Rolan", "pub_time": "2018-2-22 00:48", "content": "书接上文哈咱们定义了个状态管理对象 逻辑应该是这样的 if (json.product.activity.type == \"Coin1\") {\r\n                this.activity.coin1Show = now > json.product.activity.preAt && now < json.product.activity.postAt\r\n            }\r\n\r\n            if (this.activity.coin1Show) {\r\n                this.activity.unStart = now < json.product.activity.startAt;\r\n                this.activity.ended = now > json.product.activity.endAt;\r\n                this.activity.doing = this.activity.unStart == false && this.activity.ended == false;\r\n            }\r\n\r\n            this.activity = this.activity;preAt 为活动开始提前的时间postAt为活动开始延后的时间也就是 如果商品属于咱们的活动当中 ok，那咱们判断下当前时间 是不是满足这个两个条件， 如果满足那么this.activity.coin1Show = true为ture是什么意思？意思就是活动按钮出现了啊，忘记的可以看一下微信小程序之状态管理A中的代码段，默认值为false，然后让按钮是否出现也按照这个条件判断 只要确定了活动按钮的出现的时间 那么其余的条件就好判断了  上文中的图还有印象么？就是这样的所以说 按钮只要出来了，其余的条件就在 当按钮出来后的逻辑里面再次判断当前时间是属于哪个节点的，利用逻辑后的true 和false来赋值我们在page——data——activity中定义的哪个状态管理的相应的属性，从而让活动按钮什么时候展示相应的状态。小弟不才，文笔不好，思路是依据公司的大牛的思路自己整理的，因为我做的这个 真是惨不忍睹，所以被重构了一次，但是，咱不得总结么 是不是，所以以此文 来记录下我的成长 哈哈哈若能帮助到您 那就更好了，也希望大家多多积累，才会进步"}
{"title": "微信小程序-setData()方法 ", "author": "Rolan", "pub_time": "2018-2-27 00:37", "content": "一般setData方法多用于点击后改变页面信息或者刷新后与后台交互获取最新的信息注意：直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。方法如下：js:Page({\r\n  data: {\r\n    text: 'init data',\r\n    num: 0,\r\n    array: [{text: 'init data'}],\r\n    object: {\r\n      text: 'init data'\r\n    }\r\n  },\r\n  changeText: function() {\r\n    // this.data.text = 'changed data'  // bad, it can not work\r\n    this.setData({\r\n      text: 'changed data'\r\n    })\r\n  },\r\n  changeNum: function() {\r\n    this.data.num = 1\r\n    this.setData({\r\n      num: this.data.num\r\n    })\r\n  },\r\n  changeItemInArray: function() {\r\n    // you can use this way to modify a danamic data path\r\n    this.setData({\r\n      'array[0].text':'changed data'\r\n    })\r\n  },\r\n  changeItemInObject: function(){\r\n    this.setData({\r\n      'object.text': 'changed data'\r\n    });\r\n  },\r\n  addNewField: function() {\r\n    this.setData({\r\n      'newField.text': 'new data'\r\n    })\r\n  }\r\n})wxml:<view>{{text}}</view>\r\n<button bindtap=\"changeText\"> Change normal data </button>\r\n<view>{{num}}</view>\r\n<button bindtap=\"changeNum\"> Change normal num </button>\r\n<view>{{array[0].text}}</view>\r\n<button bindtap=\"changeItemInArray\"> Change Array data </button>\r\n<view>{{object.text}}</view>\r\n<button bindtap=\"changeItemInObject\"> Change Object data </button>\r\n<view>{{newField.text}}</view>\r\n<button bindtap=\"addNewField\"> Add new data </button>"}
{"title": "微信小程序 全选和取消全选 ", "author": "Rolan", "pub_time": "2018-2-28 00:08", "content": "想要实现的效果：点击全选时，所有商品全部选中，图标为黑色选中状态，点击其中一个取消选中状态，全选按钮也随之为取消选中状态，当再次点击全选时，所有商品全部取消选中，如果分别把所有商品一个个选中，全选按钮会再次变为选中状态js:data: {\r\n    define:true,\r\n    total_num:\"0\",\r\n    sc_object:[\r\n      {\r\n        sc_title:\"嘻哈帮街舞\",\r\n        sc_imgsrc:\"../../images/growup_img.png\",\r\n        sc_name:\"嘻哈帮定制周年庆短袖\",\r\n        sc_detail:\"红色-M号\",\r\n        sc_price:\"188\",\r\n        sc_num:\"1\",\r\n        sc_total:\"188\",\r\n        state:0,\r\n        editor_url:\"../order_editor/order_editor\"\r\n       \r\n      },\r\n      {\r\n        sc_title: \"嘻哈帮街舞\",\r\n        sc_imgsrc: \"../../images/growup_img.png\",\r\n        sc_name: \"嘻哈帮定制周年庆短袖\",\r\n        sc_detail: \"红色-M号\",\r\n        sc_price: \"188\",\r\n        sc_num: \"1\",\r\n        sc_total: \"188\",\r\n        state: 0,\r\n        editor_url: \"../order_editor/order_editor\"\r\n      },\r\n      {\r\n        sc_title: \"嘻哈帮街舞\",\r\n        sc_imgsrc: \"../../images/growup_img.png\",\r\n        sc_name: \"嘻哈帮定制周年庆短袖\",\r\n        sc_detail: \"红色-M号\",\r\n        sc_price: \"188\",\r\n        sc_num: \"1\",\r\n        sc_total: \"188\",\r\n        state: 0,\r\n        editor_url: \"../order_editor/order_editor\"\r\n      }\r\n    ]\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n  \r\n  },\r\n  select_add: function (e) {\r\n    var index = e.currentTarget.dataset.index;\r\n    var array = this.data.sc_object;\r\n    if (array[index].state == 1) {\r\n      array[index].state = 0;\r\n    } else if (array[index].state == 0) {\r\n      array[index].state = 1;\r\n    }\r\n    var num=0;\r\n    var aa=0;\r\n    for(var i=0;i<array.length;i++){\r\n      var single_num = parseInt(array[i].sc_total);\r\n      if(array[i].state==1){\r\n        num=num+1;\r\n        aa=aa+single_num\r\n      }\r\n      if (num ==array.length){\r\n        this.setData({\r\n          define:false\r\n        })\r\n      }else{\r\n        this.setData({\r\n          define:true\r\n        })\r\n      }\r\n    }\r\n    this.setData({\r\n      sc_object: this.data.sc_object,\r\n      total_num:aa\r\n    });\r\n  },\r\n  switchTab1: function (e) {\r\n    var that = this;\r\n    let define = that.data.define;\r\n    var num1=that.data.num1;\r\n    define = !define;\r\n    var array = that.data.sc_object;\r\n    var aa=0;\r\n    for(var i=0;i<array.length;i++){\r\n      var nn = array[i].state;\r\n      var single_num = parseInt(array[i].sc_total);\r\n      if(define==true){\r\n        array[i].state=0\r\n      }else{\r\n        array[i].state = 1\r\n        aa = aa + single_num;\r\n      } \r\n    }\r\n    that.setData({\r\n      define: define,\r\n      sc_object: this.data.sc_object,\r\n      total_num:aa\r\n    })\r\n  },"}
{"title": "突破微信小程序模板消息限制，实现无限制主动推送 ", "author": "Rolan", "pub_time": "2018-2-28 00:26", "content": "需求背景基于微信的通知渠道，微信小程序为开发者提供了可以高效触达用户的模板消息能力，在用户本人与小程序页面有交互行为后触发，通过微信聊天列表中的服务通知可快捷进入查看消息，点击查看详情还能跳转到下发消息的小程序的指定页面。微信小程序允许下发模板消息的条件分为两类：支付或者提交表单。通过提交表单来下发模板消息的限制为“允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下条数独立，相互不影响）”。然而，用户1次触发7天内推送1条通知是明显不够用的。比如，签到功能利用模板消息的推送来提醒用户每天签到，只能在用户前一天签到的情况下，获取一次推送模板消息的机会，然后用于第二天向该用户发送签到提醒。但是很多情况下，用户在某一天忘记签到，系统便失去了提醒用户的权限，导致和用户断开了联系；再比如，系统想主动告知用户即将做某活动，然而由于微信小程序被动触发通知的限制，系统将无法主动推送消息。如何突破模板消息的推送限制？突破口：“1次提交表单可下发1条，多次提交下发条数独立，相互不影响”为了突破模板消息的推送限制，实现7天内任性推送，只需收集到足够的推送码，即每次提交表单时获取到的formId。一个formId代表着开发者有向当前用户推送模板消息的一次权限。客户端收集推送码当表单组件中的属性report-submit=true时表示发送模板消息，提交表单便可以获取formId。接下来只要对原先的页面进行改造，将用户原先绑定了点击事件的界面用表单组件中的button按钮组件来代替，即把用户的交互点击的bindtap事件由表单bindsubmit来代替，从而捕获用户的点击事件来生成更多的推送码。// 收集推送码\r\nPage({\r\n   formSubmit: funcition(e) {\r\nlet formId = e.detail.formId;\r\nthis.collectFormIds(formId); //保存推送码\r\nlet type = e.detail.target.dataset.type; // 根据type执行点击事件\r\n},\r\n\r\n   collectFormIds: function(formId) { \r\nlet formIds = app.globalData.globalFormIds; // 获取全局推送码数组\r\nif (!formIds)\r\n           formIds = [];\r\nlet data = {\r\n           formId: formId,\r\n           expire: new Data().getTime() + 60480000 // 7天后的过期时间戳\r\n}\r\n       formIds.push(data);\r\n       app.globalData.globalFormIds = formIds;\r\n},\r\n})\r\n上报推送码等待用户下一次发起网络请求时，将globalFormIds发送给服务器。// 上报推送码\r\nPage({\r\n   onLoad: funcition(e) {\r\nthis.uploadFormIds(); //上传推送码\r\n},\r\n\r\n   collectFormIds: function(formId) { \r\nvar formIds = app.globalData.globalFormIds; // 获取全局推送码\r\nif (formIds.length) {\r\n            formIds = JSON.stringify(formIds); // 转换成JSON字符串\r\n            app.globalData.gloabalFomIds = ''; // 清空当前全局推送码\r\n}\r\n       wx.request({ // 发送到服务器\r\n           url: 'http://xxx',\r\n           method: 'POST',\r\n           data: {\r\n               openId: 'openId',\r\n               formIds: formIds\r\n},\r\n           success: function(res) {\r\n}\r\n});\r\n},\r\n})\r\n服务端存储推送码高频IO，采用Redis来存储推送码。/**\r\n* 收集用户推送码\r\n*\r\n* @param openId        用户的openid\r\n* @param formTemplates 用户的表单模板\r\n*/\r\npublic void collect(String openId, List<FormTemplateVO> formTemplates) {\r\n   redisTemplate.opsForList().rightPushAll(\"mina:openid:\" + openId, formTemplates);\r\n}\r\n推送模板消息下面实现了群发的功能，针对特定用户类似。/**\r\n* 推送消息\r\n*\r\n* @param templateId 模板消息id\r\n* @param page       跳转页面\r\n* @param keyWords   模板内容\r\n*/\r\npublic void push(String templateId, String page, String keyWords) {\r\nString logPrefix = \"推送消息\";\r\n\r\n// 获取access token\r\nString accessToken = this.getAccessToken();\r\n\r\n// 创建消息通用模板\r\nMsgTemplateVO msgTemplateVO = MsgTemplateVO.builder().template_id(templateId).build();\r\n// 跳转页面\r\n   msgTemplateVO.setPage(StringUtils.isNotBlank(page) ? page : \"\");\r\n// 模板内容\r\nif (StringUtils.isNotBlank(keyWords)) {\r\nString[] keyWordArr = keyWords.split(BaseConsts.COMMA_STR);\r\nMap<String, MsgTemplateVO.KeyWord> keyWordMap = new HashMap<>(8);\r\nfor (int i = 0; i < keyWordArr.length; i++) {\r\nMsgTemplateVO.KeyWord keyWord = msgTemplateVO.new KeyWord(keyWordArr[i]);\r\n           keyWordMap.put(MsgTemplateVO.KEYWORD + (i + 1), keyWord);\r\n}\r\n       msgTemplateVO.setData(keyWordMap);\r\n} else {\r\n       msgTemplateVO.setData(Collections.emptyMap());\r\n}\r\n\r\n// 获取所有用户\r\nList<String> openIdList = minaRedisDao.getAllOpenIds();\r\n\r\nfor (String openId : openIdList) {\r\n// 获取有效推送码\r\nString formId = minaRedisDao.getValidFormId(openId);\r\nif (StringUtils.isBlank(formId)) {\r\n           LOGGER.error(\"{}>>>openId={}>>>已无有效推送码[失败]\", logPrefix, openId);\r\ncontinue;\r\n}\r\n\r\n// 指派消息\r\nMsgTemplateVO assignMsgTemplateVO = msgTemplateVO.assign(openId, formId);\r\n\r\n// 发送消息\r\nMap<String, Object> resultMap;\r\ntry {\r\nString jsonBody = JsonUtils.getObjectMapper().writeValueAsString(assignMsgTemplateVO);\r\n\r\nString resultBody = OkHttpUtils.getInstance().postAsString(messageUrl + accessToken, jsonBody);\r\n           resultMap = JsonUtils.getObjectMapper().readValue(resultBody, Map.class);\r\n} catch (IOException e) {\r\n           LOGGER.error(\"{}>>>openId={}>>>{}[失败]\", logPrefix, openId, e.getMessage(), e);\r\ncontinue;\r\n}\r\n\r\nif ((int) resultMap.get(ResponseConsts.Mina.CODE) != 0) {\r\n           LOGGER.error(\"{}>>>openId={}>>>{}[失败]\", logPrefix, openId, resultMap.get(ResponseConsts.Mina.MSG));\r\ncontinue;\r\n}\r\n\r\n       LOGGER.info(\"{}>>>openId={}>>>[成功]\", logPrefix, openId);\r\n}\r\n}\r\n\r\n/**\r\n* 根据用户获取有效的推送码\r\n*\r\n* @param openId 用户的openid\r\n* @return 推送码\r\n*/\r\npublic String getValidFormId(String openId) {\r\nList<FormTemplateVO> formTemplates = redisTemplate.opsForList().range(\"mina:openid:\" + openId, 0, -1);\r\n\r\nString validFormId = \"\";\r\nint trimStart = 0;\r\n\r\nint size;\r\nfor (int i = 0; i < (size = formTemplates.size()); i++) {\r\nif (formTemplates.get(i).getExpire() > System.currentTimeMillis()) {\r\n           validFormId = formTemplates.get(i).getFormId();\r\n           trimStart = i + 1;\r\nbreak;\r\n}\r\n}\r\n\r\n// 移除本次使用的和已过期的\r\n   redisTemplate.opsForList().trim(KEY_MINA_PUSH + openId, trimStart == 0 ? size : trimStart, -1);\r\n\r\nreturn validFormId;\r\n}\r\n以上方案可以实现在用户最后一次使用小程序后的7天内，对用户发送多条模板消息唤回用户。作者：Joker_Coding 链接：https://www.jianshu.com/p/3b02d75ef0dc 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
